syntax = "proto3";
package upns;

// TODO: The id field might be obsolete. Hash can always be generated.

/**
 * \brief A Tree like structure (commit: collection of maps, map: collection of layers, layer: collection of entities)
 *
 * A tree itself does not have a name. Each subelement of the tree does have a name.
 * The id is the (sha) checksum of the referenced object (binary)
 * The name is used to identify the object across versions.
 *
 * Versioning will be implemented in two steps:
 * 1) Every object has a name (unique in the tree) and id (globaly uniqe, two ids reference the same object).
 *    Objects can be read and can be written to.
 * 2) Objects can be read in the context of a commit OR a rolling commit (aka checkout).
 *    When writing in the context of this commit, changes are indexed/appended to a protocol.
 */
message Tree {
    map<string, ObjectReference> refs = 2;
}

//// TODO: Entity may be ObjectReference
//// ids may have the form <checkoutname>_path for objects with rehashing pending.
//// when changing objects this id must not change
message ObjectReference {
    string id = 1; // another tree, or entity. TODO: Remove member "layers" from map and "entities" from layer.
    int64 lastChange = 2; // unix time
    string meta = 3;
}

// Not a good idea as it would be possible to build a hierarchy of objects in one object
//message GenericEntryOrReference
//{
//    GenericEntry entry = 1;
//    string reference = 2;
//}


// TODO: Using MessageType and GenericMessage would be more elegant (and performant?)
// Maybe give GenericEntry the filed "id" and remove it from concrete classes
enum MessageType
{
    MessageTree = 0;
    MessageEntity = 1;
    MessageCommit = 2;
    MessageCheckout = 3;
    MessageBranch = 4;
    MessageEntityData = 5;
    MessageEmpty = 6;
}

message GenericEntry
{
    MessageType type = 1;

    Tree tree = 2;
    Entity entity = 3;
    Commit commit = 4;
    CheckoutObj checkout = 5;
    Branch branch = 6;
    bytes entityData = 7; // may be zero and stream contains data afterwards this object
}

/**
 * \brief A map containing multiple layers, grouping them logically together.
 *
 * The layers of a map share the same coordinate system. If an operation on the map's layers results in a layer,
 * which remains in the same coordinate system, a layer will be added to the originating map (for most operators \sa Operator ).
 * If the layer is not in the same coordinate system, a new map will be created.
 */

//message Map {
//  string name = 1;
//  int64 id = 2;

//  int64 lastChange = 3; // unix time

//  repeated Layer layers = 4;
//}

/**
 * \brief Type of binary layerdata saved
 * For each type correspnding wrappers must exist which handle serialization of a layer using \sa LayerDataStreamProvider.
 * Moreover spartial requests must be made possible by such a module \sa LayerData.
 */
enum LayerType {
  NONE = 0;
  POINTCLOUD2 = 1;
  OCTOMAP = 2;
  OPENVDB = 3;
  POSES = 4;
  LAST_PREDEFINED = 5;
}
enum LayerUsageType {
  LASER = 0;
  RADAR = 1;
  NAVIGATION = 2;
  ANNOTATION = 3;
}

//message Layer {
//  string name = 1;
//  string id = 2;
//  LayerType type = 3;
//  LayerUsageType usageType = 4;
//  repeated Entity entities = 5;
//}

message Entity {
  string dataId = 1; // Hash of the complete entity data stream
  LayerType type = 3;
  LayerUsageType usageType = 4;
  TransformRef transform = 5;
}

// Reference a pose in time on a path. This is maybe not enough, depending on transform tree.
message TransformRef {
    string parentId = 1;
    int64 timestamp = 2;
  LayerType type = 4;
}

message Transform {
  float m00 = 1; // scale x
  float m01 = 2;
  float m02 = 3;
  float m03 = 4;
  float m10 = 5;
  float m11 = 6; // scale y
  float m12 = 7;
  float m13 = 8;
  float m20 = 9;
  float m21 = 10;
  float m22 = 11;
  float m23 = 12;
  float m30 = 13; // x
  float m31 = 14; // y
  float m32 = 15; // z
  float m33 = 16; // scale z
  int64 id = 17;
  int64 parentId = 18; // if parentId is 0, the transform is absolute and in the same coordinate system as the map's root transform
  int64 timestamp = 19; // 32bit seconds and 32bit nanoseconds
  repeated string tags = 20; // can be used to do things like: find the first transform in hierarchy with tag "robot"
}
message CommitRef {
    Commit commit = 1;
    Branch branch = 2;
//    CommitRef ref = 3; // complete git ref syntax can not be implemented using members here
//    int32 ancestor = 4;
//    int32 sibling = 5;
}

message Branch {
//    string name = 1;
    string commitId = 2;
}

message CheckoutObj {
    Commit rollingCommit = 1; // This commit is exclusive for this checkout. It's parent is the last commit that is sealed and has no paths as ids.
    // stored references or copies. Contains all data of the checkout.
    // Advantage over git. no copy is created
    // TODO: Not needed ?
    //repeated string transientOids = 2;
    map<string, string> transientOidsToOrigin = 2;
}

message Commit {
    string commitMessage = 1;
    string author = 2;
    int64  datetime = 3;
    repeated string parentCommitIds = 4;
    repeated OperationDescription ops = 5; // Also tracks renames via "update metadata" operator. Thus the history of a map can be restored, although the name changed.
//    repeated ObjectVersion maps = 4;
//    repeated ObjectVersion entities = 5;

    // Maps objectIds in this commit to Ids from parentCommit. TODO: Must be a multimap? in a merge, there might be multiple parents.
    // Note: deletions are transitions to -> NULL?
    message ObjectIdPair {
        string sourceObjectId = 1;
        string parentObjectId = 2;
    }

    repeated ObjectIdPair transitions = 6;

    // contains all hashes after each (StreamProvider write) step
    message ObjectIdList {
        string sourceObjectId = 1;
        repeated string objectId = 2;
    }
    repeated ObjectIdList detailedTransitions = 7;

    // Entrypoint to Tree with children hierarchy: root-> maps -> layers -> entities
    string root = 8;
}

message Conflict {
    string path = 1;
    repeated string objectIds = 2;
}

//message ObjectVersion {
//    int64 id = 1;
//    string commitId = 2;
//}

message OperationDescription {
    string operatorName = 1;
    int32 operatorVersion = 2;
    string params = 3;
    //repeated OperationParameter params = 3;
}

//message OperationParameter {
//    string                        key = 1;

//    //optional, set one of these three
//    int64                         intval = 2;
//    double                        realval = 3;
//    string                        strval = 4;
//    //string                        transformval = 5; //< is in object

//    string objectId = 5;

//    //... or set 1) map; 2) map and layer; 3) map, layer and entity
//    int64      entityval = 7; //deprecated
//    int64       layerval = 8; //deprecated
//    int64         mapval = 9; //deprecated
//}

//message OperationParameterEntity {
//    int64 mapId = 1;
//    int64 layerId = 2;
//    int64 entityId = 3;
//}
//message OperationParameterLayer {
//    int64 mapId = 1;
//    int64 layerId = 2;
//}
//message OperationParameterMap {
//    int64 mapId = 1;
//}

//message OperationParameterTransform {
//    int64 tfId = 1;
//}

message Region {
  int64 layerId = 1;

  float minx = 2;
  float maxx = 3;
  float miny = 4;
  float maxy = 5;
  float minz = 6;
  float maxz = 7;
  int32 levelOfDetail = 8;
  bool announce = 9;
  ClipMode clipMode = 10;

  enum ClipMode {
    EXACT = 0;
    SURROUNDING = 1;
  }
}

message RegionData {
  int64 dataSize = 1;
  // Coded Stream if dataSize > 0
}

//temporary use prototype for pointcloud2
message Pointcloud2Header {
    uint32 seq = 1;
    uint64 stamp = 2;
    string frame_id = 3;
}

message Pointcloud2PointField {
    string name = 1;
    uint32 offset = 2;
    int32 datatype = 3;
    uint32 count = 4;
}

message Pointcloud2 {
    Pointcloud2Header header = 1;
    uint32 height = 2;
    uint32 width = 3;

    repeated Pointcloud2PointField fields = 4;

    bool is_bigendian = 5;
    uint32 point_step = 6;
    uint32 row_step = 7;
    bytes data = 8;
    bool is_dense = 9;
}

message ListMapsRequest {}

//service MapService {
//  rpc ListMaps (ListMapsRequest) returns (stream Map);
//}

//service LayerService {
//  rpc GetRegion ( Region ) returns (stream RegionData);
//}
