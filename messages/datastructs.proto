syntax = "proto3";
package mapit.msgs;

// TODO: The id field might be obsolete. Hash can always be generated.

/**
 * \brief A Tree like structure (commit: collection of maps, map: collection of layers, layer: collection of entities)
 *
 * A tree itself does not have a name. Each subelement of the tree does have a name.
 * The id is the (sha) checksum of the referenced object (binary)
 * The name is used to identify the object across versions.
 *
 * Versioning will be implemented in two steps:
 * 1) Every object has a name (unique in the tree) and id (globaly uniqe, two ids reference the same object).
 *    Objects can be read and can be written to.
 * 2) Objects can be read in the context of a commit OR a rolling commit (aka checkout).
 *    When writing in the context of this commit, changes are indexed/appended to a protocol.
 */
message Tree {
  enum CompType {
    PROTO_3  = 0;
    COMP_ID  = 1;
    MSG_TYPE = 2;
  }
    map<string, ObjectReference> refs = 2;
}

//// TODO: Entity may be ObjectReference
//// id or path: only exactly one of them must be set. id xor path.
//// path is [/]<checkoutname>/[<tree>/.../<entity>]
message ObjectReference {
  enum CompType {
    PROTO_3  = 0;
    COMP_ID  = 1;
    MSG_TYPE = 3;
  }
    string id = 1; // another tree, or entity. TODO: Remove member "layers" from map and "entities" from layer.
    string path = 2;
    //int64 lastChange = 3; // unix time
    //string meta = 4;
}

// Not a good idea as it would be possible to build a hierarchy of objects in one object
//message GenericEntryOrReference
//{
//    GenericEntry entry = 1;
//    string reference = 2;
//}


// TODO: Using MessageType and GenericMessage would be more elegant (and performant?)
// Maybe give GenericEntry the filed "id" and remove it from concrete classes
enum MessageType
{
    MessageTree = 0;
    MessageEntity = 1;
    MessageCommit = 2;
    MessageCheckout = 3;
    MessageBranch = 4;
    MessageEntitydata = 5;
    MessageEmpty = 6;
}

message GenericEntry
{
    MessageType type = 1;

    Tree tree = 2;
    Entity entity = 3;
    Commit commit = 4;
    CheckoutObj checkout = 5;
    Branch branch = 6;
    bytes entityData = 7; // may be zero and stream contains data afterwards this object
}

/**
 * \brief A map containing multiple layers, grouping them logically together.
 *
 * The layers of a map share the same coordinate system. If an operation on the map's layers results in a layer,
 * which remains in the same coordinate system, a layer will be added to the originating map (for most operators \sa Operator ).
 * If the layer is not in the same coordinate system, a new map will be created.
 */

//message Map {
//  string name = 1;
//  int64 id = 2;

//  int64 lastChange = 3; // unix time

//  repeated Layer layers = 4;
//}

/**
 * \brief Type of binary layerdata saved
 * For each type correspnding wrappers must exist which handle serialization of a layer using \sa LayerDataStreamProvider.
 * Moreover spartial requests must be made possible by such a module \sa LayerData.
 */
enum LayerType {
  NONE = 0;
  ANY_RAW = 1;
  POINTCLOUD = 4;
  OCTOMAP = 5;
  OPENVDB = 6;
  TF = 7;
  BOUNDINGBOX = 8;
  ASSET = 9;
  LAST_PREDEFINED = 32;
}
enum LayerUsageType {
  LASER = 0;
  RADAR = 1;
  NAVIGATION = 2;
  ANNOTATION = 3;
}

//message Layer {
//  string name = 1;
//  string id = 2;
//  LayerType type = 3;
//  LayerUsageType usageType = 4;
//  repeated Entity entities = 5;
//}

message Entity {
  enum CompType {
    PROTO_3  = 0;
    COMP_ID  = 1;
    MSG_TYPE = 4;
  }
  string dataId = 1; // Hash of the complete entity data stream
  //LayerType type = 3;
  string type = 3;
  LayerUsageType usageType = 4;
}

message Transform {
    enum CompType {
        PROTO_3  = 0;
        COMP_ID  = 1;
        MSG_TYPE = 5;
    }
    float m00 = 1; // scale x
    float m01 = 2;
    float m02 = 3;
    float m03 = 4;
    float m10 = 5;
    float m11 = 6; // scale y
    float m12 = 7;
    float m13 = 8;
    float m20 = 9;
    float m21 = 10;
    float m22 = 11;
    float m23 = 12;
    float m30 = 13; // x
    float m31 = 14; // y
    float m32 = 15; // z
    float m33 = 16; // scale z
    int64 id = 17;
    int64 parentId = 18; // if parentId is 0, the transform is absolute and in the same coordinate system as the map's root transform
    int64 timestamp = 19; // 32bit seconds and 32bit nanoseconds
    repeated string tags = 20; // can be used to do things like: find the first transform in hierarchy with tag "robot"
}
message TransformPath {
    enum CompType {
      PROTO_3  = 0;
      COMP_ID  = 1;
      MSG_TYPE = 51;
    }
    repeated Transform transforms = 1;
}

message Pose {
    enum CompType {
      PROTO_3  = 0;
      COMP_ID  = 1;
      MSG_TYPE = 52;
    }
    float x = 1;
    float y = 2;
    float z = 3;
    float dir_x = 4;
    float dir_y = 5;
    float dir_z = 6;
    int64 timestamp = 7; // 32bit seconds and 32bit nanoseconds
    repeated string data = 8; // user data, additional
}

message PosePath {
    enum CompType {
      PROTO_3  = 0;
      COMP_ID  = 1;
      MSG_TYPE = 53;
    }
    repeated Pose poses = 1;
}

message Primitive {
    enum CompType {
      PROTO_3  = 0;
      COMP_ID  = 1;
      MSG_TYPE = 60;
    }
    // All primitives are 1 unit in size and must be transformed to fit
    enum PrimitiveType {
      SPHERE  = 0;
      CUBE  = 1;
      PLANE = 2;
      CYLINDER = 3;
      CAPSULE = 4;
      CONE = 5;
      DISC = 6;
      POINT = 7;
      ARROW = 8;
      LINE = 9;
      TEXT = 10;
      ICON = 11;
    }
    PrimitiveType type = 1;
    string text = 2;
    string data = 3;
}

message Boundingbox {
  enum CompType {
    PROTO_3  = 0;
    COMP_ID  = 1;
    MSG_TYPE = 50;
  }
  float x1 = 1; // left
  float y1 = 2; // top
  float x2 = 3; // right
  float y2 = 4; // bottom
}

message CommitRef {
  enum CompType {
    PROTO_3  = 0;
    COMP_ID  = 1;
    MSG_TYPE = 6;
  }
    Commit commit = 1;
    Branch branch = 2;
//    CommitRef ref = 3; // complete git ref syntax can not be implemented using members here
//    int32 ancestor = 4;
//    int32 sibling = 5;
}

message Branch {
  enum CompType {
    PROTO_3  = 0;
    COMP_ID  = 1;
    MSG_TYPE = 7;
  }
//    string name = 1;
    string commitId = 2;
}

message CheckoutObj {
  enum CompType {
    PROTO_3  = 0;
    COMP_ID  = 1;
    MSG_TYPE = 8;
  }
    Commit rollingCommit = 1; // This commit is exclusive for this checkout. It's parent is the last commit that is sealed and has no paths as ids.
    // stored references or copies. Contains all data of the checkout.
    // Advantage over git. no copy is created
    // TODO: Not needed ?
    //repeated string transientOids = 2;
    map<string, string> transientOidsToOrigin = 2;
}

message Commit {
  enum CompType {
    PROTO_3  = 0;
    COMP_ID  = 1;
    MSG_TYPE = 9;
  }
    string commitMessage = 1;
    string author = 2;
    int64  datetime = 3;
    repeated string parentCommitIds = 4;
    repeated OperationDescription ops = 5; // Also tracks renames via "update metadata" operator. Thus the history of a map can be restored, although the name changed.
//    repeated ObjectVersion maps = 4;
//    repeated ObjectVersion entities = 5;

    // Maps objectIds in this commit to Ids from parentCommit. TODO: Must be a multimap? in a merge, there might be multiple parents.
    // Note: deletions are transitions to -> NULL?
    message ObjectIdPair {
        string sourceObjectId = 1;
        string parentObjectId = 2;
    }

    repeated ObjectIdPair transitions = 6;

    // contains all hashes after each (StreamProvider write) step
    message ObjectIdList {
        string sourceObjectId = 1;
        repeated string objectId = 2;
    }
    repeated ObjectIdList detailedTransitions = 7;

    // Entrypoint to Tree with children hierarchy: root-> maps -> layers -> entities
    ObjectReference root = 8;
}

message Conflict {
  enum CompType {
    PROTO_3  = 0;
    COMP_ID  = 1;
    MSG_TYPE = 10;
  }
    string path = 1;
    repeated string objectIds = 2;
}

//message ObjectVersion {
//    int64 id = 1;
//    string commitId = 2;
//}
message OperatorDescription {
  enum CompType {
    PROTO_3  = 0;
    COMP_ID  = 1;
    MSG_TYPE = 15;
  }
    string operatorName = 1;
    int32 operatorVersion = 2;
}

message OperationDescription {
  enum CompType {
    PROTO_3  = 0;
    COMP_ID  = 1;
    MSG_TYPE = 11;
  }
    OperatorDescription operator = 1;
    string params = 3;
}

//temporary use prototype for pointcloud2
message Pointcloud2Header {
  enum CompType {
    PROTO_3  = 0;
    COMP_ID  = 1;
    MSG_TYPE = 12;
  }
    uint32 seq = 1;
    uint64 stamp = 2;
    string frame_id = 3;
}

message Pointcloud2PointField {
  enum CompType {
    PROTO_3  = 0;
    COMP_ID  = 1;
    MSG_TYPE = 13;
  }
    string name = 1;
    uint32 offset = 2;
    int32 datatype = 3;
    uint32 count = 4;
}

message Pointcloud2 {
  enum CompType {
    PROTO_3  = 0;
    COMP_ID  = 1;
    MSG_TYPE = 14;
  }
    Pointcloud2Header header = 1;
    uint32 height = 2;
    uint32 width = 3;

    repeated Pointcloud2PointField fields = 4;

    bool is_bigendian = 5;
    uint32 point_step = 6;
    uint32 row_step = 7;
    bytes data = 8;
    bool is_dense = 9;
}
