syntax = "proto3";
package upns;

// TODO: The id field might be obsolete. Hash can always be generated.

/**
 * \brief A Tree like structure (commit: collection of maps, map: collection of layers, layer: collection of entities)
 *
 * A tree itself does not have a name. Each subelement of the tree does have a name.
 * The id is the (sha) checksum of the referenced object (binary)
 * The name is used to identify the object across versions.
 *
 * Versioning will be implemented in two steps:
 * 1) Every object has a name (unique in the tree) and id (globaly uniqe, two ids reference the same object).
 *    Objects can be read and can be written to.
 * 2) Objects can be read in the context of a commit OR a rolling commit (aka checkout).
 *    When writing in the context of this commit, changes are indexed/appended to a protocol.
 */
message Tree {
    string id = 1;
    map<string, ObjectReference> refs = 2;
}

// TODO: Entity may be ObjectReference
message ObjectReference {
    string id = 1; // another tree, or entity. TODO: Remove member "layers" from map and "entities" from layer.
    int64 lastChange = 2; // unix time
    string meta = 3;
}

/**
 * \brief A map containing multiple layers, grouping them logically together.
 *
 * The layers of a map share the same coordinate system. If an operation on the map's layers results in a layer,
 * which remains in the same coordinate system, a layer will be added to the originating map (for most operators \sa Operator ).
 * If the layer is not in the same coordinate system, a new mayp will be created.
 */

//message Map {
//  string name = 1;
//  int64 id = 2;

//  int64 lastChange = 3; // unix time

//  repeated Layer layers = 4;
//}

/**
 * \brief Type of binary layerdata saved
 * For each type correspnding wrappers must exist which handle serialization of a layer using \sa LayerDataStreamProvider.
 * Moreover spartial requests must be made possible by such a module \sa LayerData.
 */
enum LayerType {
  NONE = 0;
  POINTCLOUD2 = 1;
  OCTOMAP = 2;
  OPENVDB = 3;
  POSES = 4;
  LAST_PREDEFINED = 5;
}
enum LayerUsageType {
  LASER = 0;
  RADAR = 1;
  NAVIGATION = 2;
  ANNOTATION = 3;
}

//message Layer {
//  string name = 1;
//  string id = 2;
//  LayerType type = 3;
//  LayerUsageType usageType = 4;
//  repeated Entity entities = 5;
//}

message Entity {
  string id = 1;
  string dataId = 2; // Hash of the complete entity data stream
  int64 lastChange = 3; // unix time
  LayerType type = 4;
  LayerUsageType usageType = 5;
  TransformRef transform = 6;
  LayerType type = 4;
}

// Reference a pose in time on a path. This is maybe not enough, depending on transform tree.
message TransformRef {
    string parentId = 1;
    int64 timestamp = 2;
}

message Transform {
  float m00 = 1; // scale x
  float m01 = 2;
  float m02 = 3;
  float m03 = 4;
  float m10 = 5;
  float m11 = 6; // scale y
  float m12 = 7;
  float m13 = 8;
  float m20 = 9;
  float m21 = 10;
  float m22 = 11;
  float m23 = 12;
  float m30 = 13; // x
  float m31 = 14; // y
  float m32 = 15; // z
  float m33 = 16; // scale z
  int64 id = 17;
  int64 parentId = 18; // if parentId is 0, the transform is absolute and in the same coordinate system as the map's root transform
  int64 timestamp = 19; // 32bit seconds and 32bit nanoseconds
  repeated string tags = 20; // can be used to do things like: find the first transform in hierarchy with tag "robot"
}
message CommitRef {
    Commit commit = 1;
    Branch branch = 2;
//    CommitRef ref = 3; // complete git ref syntax can not be implemented using members here
//    int32 ancestor = 4;
//    int32 sibling = 5;
}

message Branch {
//    string name = 1;
    string commitId = 2;
}

message CheckoutObj {
    Commit commit = 1;
    // stored references or copies. Contains all data of the checkout.
    // Advantage over git. not copy is created
    map<string, GenericEntryOrReference> pathToEntries = 2;
}

message Commit {
    string commitId = 1;
    repeated string parentCommitIds = 2;
    repeated OperationDescription ops = 3; // Also tracks renames via "update metadata" operator. Thus the history of a map can be restored, although the name changed.
//    repeated ObjectVersion maps = 4;
//    repeated ObjectVersion entities = 5;

    // Maps objectIds in this commit to Ids from parentCommit. TODO: Must be a multimap? in a merge, there might be multiple parents.
    // Note: deletions are transitions to -> NULL?
    message ObjectIdPair {
        string sourceObjectId = 1;
        string parentObjectId = 2;
    }

    repeated ObjectIdPair transitions = 4;

    // contains all hashes after each (StreamProvider write) step
    message ObjectIdList {
        string sourceObjectId = 1;
        repeated string objectId = 2;
    }
    repeated ObjectIdList detailedTransitions = 5;

    // Entrypoint to Tree with children hierarchy: root-> maps -> layers -> entities
    string root = 6;
}

message Conflict {
    string path = 1;
    repeated string objectIds = 2;
}

//message ObjectVersion {
//    int64 id = 1;
//    string commitId = 2;
//}

message OperationDescription {
    string operatorName = 1;
    int32 operatorVersion = 2;
    repeated OperationParameter params = 3;
}

message OperationParameter {
    string                        key = 1;

    //optional, set one of these three
    int64                         intval = 2;
    double                        realval = 3;
    string                        strval = 4;
    //string                        transformval = 5; //< is in object

    string objectId = 5;

    //... or set 1) map; 2) map and layer; 3) map, layer and entity
    int64      entityval = 7; //deprecated
    int64       layerval = 8; //deprecated
    int64         mapval = 9; //deprecated
}

//message OperationParameterEntity {
//    int64 mapId = 1;
//    int64 layerId = 2;
//    int64 entityId = 3;
//}
//message OperationParameterLayer {
//    int64 mapId = 1;
//    int64 layerId = 2;
//}
//message OperationParameterMap {
//    int64 mapId = 1;
//}

//message OperationParameterTransform {
//    int64 tfId = 1;
//}

message Region {
  int64 layerId = 1;

  float minx = 2;
  float maxx = 3;
  float miny = 4;
  float maxy = 5;
  float minz = 6;
  float maxz = 7;
  int32 levelOfDetail = 8;
  bool announce = 9;
  ClipMode clipMode = 10;

  enum ClipMode {
    EXACT = 0;
    SURROUNDING = 1;
  }
}

message RegionData {
  int64 dataSize = 1;
  // Coded Stream if dataSize > 0
}

/*message Pointcloud2Header {
ar & header.seq;
ar & header.stamp;
ar & header.frame_id;
}
message Pointcloud2PointField {
ar & f.name;
ar & f.offset;
ar & f.datatype;
ar & f.count;
}

message Pointcloud2 {
    Pointcloud2Header header = 1;
    int height = 2;
    int width = 3;

    int fields = 4;
ar & v.header;
ar & v.height;
ar & v.width;

ar & v.fields;
ar & v.is_bigendian;
ar & v.point_step;
ar & v.row_step;
ar & v.data;
ar & v.is_dense;
}*/

message ListMapsRequest {}

enum MessageType
{
    MessageTree = 0;
    MessageEntity = 1;
    MessageCommit = 2;
    MessageCheckout = 3;
    MessageBranch = 4;
    MessageEntityData = 5;
    MessageEmpty = 6;
}

message GenericEntryOrRef
{
    GenericEntry entry = 1;
    string reference = 2;
}

message GenericEntry
{
    MessageType type = 1;

    Tree tree = 2;
    Entity entity = 3;
    Commit commit = 4;
    CheckoutObj checkout = 5;
    Branch branch = 6;
    bytes entityData = 7;
}

//service MapService {
//  rpc ListMaps (ListMapsRequest) returns (stream Map);
//}

//service LayerService {
//  rpc GetRegion ( Region ) returns (stream RegionData);
//}
